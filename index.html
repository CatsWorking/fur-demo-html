<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebGL Fur Demo</title>
<style>
  body { margin: 0; overflow: hidden; }
  canvas { display: block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>

<script type="x-shader/x-vertex" id="vertex-shader">
attribute vec3 aPosition;
attribute vec3 aNormal;

uniform mat4 uProjection;
uniform mat4 uView;
uniform mat4 uModel;
uniform float uTime;
uniform float uLayer;

varying float vLayer;

void main(void) {
    // Offset vertex along its normal to create fur layers
    float furOffset = uLayer * 0.05; // thickness of fur layer
    vec3 pos = aPosition + aNormal * furOffset;

    // Simple waving motion
    pos.x += sin(uTime + aPosition.y * 5.0) * 0.02;
    pos.z += cos(uTime + aPosition.y * 5.0) * 0.02;

    gl_Position = uProjection * uView * uModel * vec4(pos, 1.0);
    vLayer = uLayer;
}
</script>

<script type="x-shader/x-fragment" id="fragment-shader">
precision mediump float;
varying float vLayer;

void main(void) {
    // Gradient to simulate fur transparency
    float alpha = 1.0 - vLayer;
    gl_FragColor = vec4(0.8, 0.6, 0.4, alpha);
}
</script>

<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
gl.viewport(0, 0, canvas.width, canvas.height);
gl.enable(gl.BLEND);
gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

// Compile shaders
function compileShader(id, type) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, document.getElementById(id).text);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
    }
    return shader;
}
const vertexShader = compileShader('vertex-shader', gl.VERTEX_SHADER);
const fragmentShader = compileShader('fragment-shader', gl.FRAGMENT_SHADER);

// Create program
const program = gl.createProgram();
gl.attachShader(program, vertexShader);
gl.attachShader(program, fragmentShader);
gl.linkProgram(program);
gl.useProgram(program);

// Cube geometry for demo
const positions = new Float32Array([
    -0.5,-0.5,-0.5,  0.5,-0.5,-0.5,  0.5,0.5,-0.5, -0.5,0.5,-0.5,
    -0.5,-0.5,0.5,   0.5,-0.5,0.5,   0.5,0.5,0.5,  -0.5,0.5,0.5,
]);
const normals = new Float32Array([
    -1,0,0, 1,0,0, 0,1,0, 0,-1,0, 0,0,1, 0,0,-1
]);
const indices = new Uint16Array([
    0,1,2, 2,3,0,
    4,5,6, 6,7,4,
    0,1,5, 5,4,0,
    2,3,7, 7,6,2,
    0,3,7, 7,4,0,
    1,2,6, 6,5,1
]);

// Buffers
const posBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const posAttrib = gl.getAttribLocation(program, 'aPosition');
gl.enableVertexAttribArray(posAttrib);
gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 0, 0);

// Using normals as placeholder
const normBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, normBuffer);
gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
const normAttrib = gl.getAttribLocation(program, 'aNormal');
gl.enableVertexAttribArray(normAttrib);
gl.vertexAttribPointer(normAttrib, 3, gl.FLOAT, false, 0, 0);

const indexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

// Uniforms
const uProjection = gl.getUniformLocation(program, 'uProjection');
const uView = gl.getUniformLocation(program, 'uView');
const uModel = gl.getUniformLocation(program, 'uModel');
const uTime = gl.getUniformLocation(program, 'uTime');
const uLayer = gl.getUniformLocation(program, 'uLayer');

// Simple perspective
function perspective(fovy, aspect, near, far){
    const f = 1.0 / Math.tan(fovy / 2);
    const nf = 1 / (near - far);
    return [
        f/aspect,0,0,0,
        0,f,0,0,
        0,0,(far+near)*nf,-1,
        0,0,(2*far*near)*nf,0
    ];
}
const proj = perspective(Math.PI/4, canvas.width/canvas.height, 0.1, 100);
gl.uniformMatrix4fv(uProjection, false, new Float32Array(proj));
gl.uniformMatrix4fv(uView, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,-3,1]));
gl.uniformMatrix4fv(uModel, false, new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]));

let time = 0;
function draw(){
    time += 0.02;
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const layers = 20; // number of fur layers
    for(let i=0; i<layers; i++){
        gl.uniform1f(uLayer, i/layers);
        gl.uniform1f(uTime, time);
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    }

    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
